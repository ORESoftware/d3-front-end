<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <link rel="stylesheet" href="style.css"/>
    <title>Dragging Nodes and Alpha Values</title>
</head>

<style>
    .svg-container {
        display: inline-block;
        position: relative;
        width: 100%;
        padding-bottom: 100%;
        vertical-align: top;
        overflow: hidden;
    }

    .svg-content {
        display: inline-block;
        position: absolute;
        top: 0;
        left: 0;
    }
</style>

<body>

<div id="container" class="svg-container">
    <svg
            version="1.1"
            baseProfile="full"
            xmlns="http://www.w3.org/2000/svg"
            preserveAspectRatio="xMidYMid meet"
    ></svg>
</div>

<!-- TODO: 1. scale drawing to 90% of viewport (vertically and horizontally) -->
<!-- TODO: 2. add permanent labels to nodes -->
<!-- TODO: 3. add permanent icons to nodes (any image url is fine for now)-->
<!-- TODO: 4. allow for triangle or rectangular shapes in nodes -->
<!-- TODO: 5. add on-hover text (show metadata when hovering over) -->
<!-- TODO: 6. add dynamic text above node (gets updated constantly from backend) -->
<!-- TODO: 7. add dynamic images/drawings/animation along links (gets updated constantly from backend) -->
<!-- TODO: 8. change forces so the more force between nodes given more degrees of separation/freedom -->
<!-- TODO: 9. allow user to toggle on/off nodes self-separating - default is on - if it's off: then user can drag nodes wherever they want  -->
<!-- TODO: 10: on-hover over node -> show histogram -->
<!-- TODO: 10: on-hover over link -> show histogram -->

<!--we are using version 7 of d3, use the minified version later -->
<script src="https://d3js.org/d3.v7.js"></script>

<script>

    const fisherYatesShuffle = function* (deck) {
        for (let i = deck.length - 1; i >= 0; i--) {
            const swapIndex = Math.floor(Math.random() * (i + 1));
            [deck[i], deck[swapIndex]] = [deck[swapIndex], deck[i]];
            yield deck[i];
        }
    };

    const colors = [
        'red',
        'blue',
        'indigo',
        'violet',
        'purple',
        'orange',
        'pink',
        'yellow',
        'maroon',
        'black'
    ];


    // TODO: https://chartio.com/resources/tutorials/how-to-resize-an-svg-when-the-window-is-resized-in-d3-js/

    const run = (nodes, links) => {

        setInterval(() => {
            for(const n of fisherYatesShuffle(nodes)){
                // update node with id = n.id
                // TODO: dynamically update nodes in network here
                // TODO: down the line, will be updated with websocket conn
            }
        }, 2000);

        let width = 1900;
        let height = 500;

        let svg = d3
            .select("svg")
            .attr("width", width)
            .attr("height", height);

        // append a path marker to svg defs
        svg.append("defs").selectAll("marker")
            .data(["dominating"])
            .enter().append("marker")
            .attr("id", d => d)
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 0)
            .attr("refY", 0)
            .attr("markerWidth", 12)
            .attr("markerHeight", 12)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M0,-5L10,0L0,5");

        let linkSelection = svg
            .selectAll("line")
            .data(links)
            .enter()
            .append("line")
            .attr("stroke", "black")
            .attr("stroke-width", 1)
            // add marker to line
            .attr("marker-end", d => "url(#dominating)");


        let nodeSelection = svg
            .selectAll("circle")
            .data(nodes)
            .enter()
            .append("circle")
            .attr("r", d => d.size)
            .attr("fill", d => d.color)
            .attr("img", d => d.icon)
            .call(
                d3
                    .drag()
                    .on("start", dragStart)
                    .on("drag", drag)
                    .on("end", dragEnd)
            );


        let simulation = d3.forceSimulation(nodes);

        simulation
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("nodes", d3.forceManyBody())
            .force("radial", d3.forceRadial(240, width / 2, height / 2))
            .force("charge", d3.forceManyBody().strength(-98))
            // .force("collision", d3.forceCollide().radius(100))
            // .force('collide', d3.forceCollide().radius(function(d) {
            //     return d.radius + 150;
            // }))
            // .linkDistance(1)
            .force(
                "links",
                d3
                    .forceLink(links)
                    .id(d => d.id)
                    // .distance(d => 5 * (d.source.size + d.target.size))
                    // TODO force distance between all elements, not just connected ones
                    // TODO in fact, force should be greater amongst non-connected elements
                    // TODO idea - force should increase as degree of freedom between nodes increases
                    .distance((d,a,b) => {
                        console.log({d, a, b});
                        return 3 * (d.source.size + d.target.size);
                    })
            )
            .on("tick", ticked);

        // function isolate(force, nodeA, nodeB) {
        //     let initialize = force.initialize;
        //     force.initialize = function() {
        //         initialize.call(force, [nodeA, nodeB]);
        //     };
        //     return force;
        // }

        // data.nodes contains all nodes
        for(let i = 0; i < nodes.length - 1; i++) {
            for(let j = i + 1; j < nodes.length; j++) {
                simulation.force();
            }
        }

        function ticked() {
            // console.log(simulation.alpha());

            nodeSelection.attr("cx", d => d.x).attr("cy", d => d.y);

            linkSelection
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);


            // recalculate and back off the distance
            linkSelection.each(function (d, i, n) {
                // current path length
                const pl = this.getTotalLength();
                // radius of marker head plus def constant
                const mrs = (d.source.size);
                const mrt = (d.target.size) + 12;
                // get new start and end points
                const m1 = this.getPointAtLength(mrs);
                const m2 = this.getPointAtLength(pl - mrt);
                // new line start and end
                d3.select(n[i])
                    .attr("x1", m1.x)
                    .attr("y1", m1.y)
                    .attr("x2", m2.x)
                    .attr("y2", m2.y);
            });
        }

        function dragStart(event, d) {
            // console.log('drag start');
            simulation.alphaTarget(0.5).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function drag(event, d) {
            // console.log('dragging', event, d);
            // simulation.alpha(0.5).restart()
            d.fx = event.x;
            d.fy = event.y;
            // d.fx = d3.event.x;
            // d.fy = d3.event.y;
        }

        function dragEnd(event, d) {
            // console.log('drag end');
            simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }
    }


    const nodes = [];
    const links = [];

    const data = {
        formation: [
            {
                "name": "A",
                "id": "A",
                "entity": {
                    "initialGraphData": true
                },
                "iconUrl": "https://xyz.com",
                "label": "A",
                "connectionsOut": [
                    "B", "C"
                ]
            },
            {
                "name": "F",
                "id": "F",
                "entity": {
                    "initialGraphData": true
                },
                "iconUrl": "https://xyz.com",
                "label": "F",
                "connectionsOut": [
                   "C"
                ]
            },
            {
                "name": "B",
                "id": "B",
                "entity": {
                    "initialGraphData": true
                },
                "iconUrl": "https://xyz.com",
                "label": "B",
                "connectionsOut": [
                    "C"
                ]
            },
            {
                "name": "C",
                "id": "C",
                "entity": {
                    "initialGraphData": true
                },
                "iconUrl": "https://xyz.com",
                "label": "C",
                "connectionsOut": [
                    "D"
                ]
            },
            {
                "name": "D",
                "id": "D",
                "entity": {
                    "initialGraphData": true
                },
                "iconUrl": "https://xyz.com",
                "label": "D",
                "connectionsOut": [
                    "E"
                ]
            },
            {
                "name": "E",
                "id": "E",
                "entity": {
                    "initialGraphData": true
                },
                "iconUrl": "https://xyz.com",
                "label": "E",
                "connectionsOut": []
            }
        ]
    }

    if (data.formation) {
        for (const z of data.formation) {

            nodes.push({
                color: colors.shift(),
                size: 20, // TODO: size should be dynamic/scaled, but with a minimum and maximum size
                label: z.label,
                name: z.name,
                id: z.id,
                histogram: new Map()
            });

            // we only need-be concerned with connectionsOut, not connectionsIn, in order to complete graph
            for (const targetId of z.connectionsOut) {
                links.push({source: z.id, target: targetId, ...{whatever: 'else'}});
            }
        }

        // for (const v of nodes) {
        //   console.log(v);
        // }
        //
        // for (const v of links) {
        //   console.log(v);
        // }

        run(nodes, links);
    }


</script>
</body>
</html>

