<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <link rel="stylesheet" href="style.css"/>
    <title>Dragging Nodes and Alpha Values</title>
</head>

<style>
    body {
        margin: 0;
        background: #eee;
    }

	div#secret {
		display: none;
	}

    .svg-container {
        display: inline-block;
        position: relative;
        width: 100%;
        padding-bottom: 100%;
        vertical-align: top;
        overflow: hidden;
    }

    .svg-content {
        display: inline-block;
        position: absolute;
        top: 0;
        left: 0;
    }

    g {
        opacity: 0.6;
        transition: opacity 0.2s ease-in-out;
        overflow: visible;
        cursor: default;
    }

    g:hover {
        opacity: 1;
    }

    g div {
        height: 60px;
        width: 120px;
        padding: 10px;
        background: #fff;
        text-align: center;
        vertical-align: middle;
        white-space: pre;
        visibility: hidden;
        border-radius: 10px;
        box-shadow: 0 0 6px rgba(0, 0, 0, 0.6);
    }

    .controls {
        visibility: visible;
	}

	g:hover div {
		visibility: visible;
	}

	.histogram {
		visibility: hidden;
	}

	.show-histogram .histogram {
		visibility: inherit;
	}
/* 
    g image {
        visibility: hidden;
    }

    g:hover div {
        visibility: visible;
    }

        g image {
            visibility: hidden;
        }

        g:hover image {
            visibility: visible;
        } */
</style>

<body>
<button onclick="turnOffSim()">Turn Off Physics</button>
<button onclick="turnOnSim()">Turn On Physics</button>
<div id="container" class="svg-container">
    <!-- <svg
            class="svg-content"
            version="1.1"
            baseProfile="full"
            xmlns="http://www.w3.org/2000/svg"
            preserveAspectRatio="xMidYMid meet"
    ></svg> -->
</div>
<div id="secret"/>

<!-- DONT NEED? * TODO: 1. scale drawing to 90% of viewport (vertically and horizontally) -->
<!-- DONE TODO: 2. add permanent labels to nodes -->
<!-- DONE TODO: 3. add permanent icons to nodes (any image url is fine for now)-->
<!-- DONT NEED TODO: 4. allow for triangle or rectangular shapes in nodes -->
<!-- DONE ** TODO: 5. add on-hover text (show metadata when hovering over) -->
<!-- TODO: 6. add dynamic text above node (gets updated constantly from backend) -->
<!-- TODO: 7. add dynamic images/drawings/animation along links (gets updated constantly from backend) -->
<!-- DONT KNOW TODO: 8. change forces so the more force between nodes given more degrees of separation/freedom -->
<!-- TODO: 9. allow user to toggle on/off nodes self-separating - default is on - if it's off: then user can drag nodes wherever they want  -->
<!-- ** TODO: 11: on-hover over link -> show histogram -->
<!-- TODO: 12: create a control panel that can do the following:-->
<!--    * button to toggle physics on/off for the graph-->
<!--    * pause/unpause button (to pause a process on backend-->
<!--    * button to slow-down or speed-up backend process (change timestep) -->
<!--    * button to stop all sources (stop generating new consumables/movables on the backend)-->
<!-- DONE ** TODO: 10: on-click node -> show histogram -->
<!-- ** TODO: 11: code histogram into metadata toggle -->
<!-- TODO: 13: control panel at top: movable -->
<!-- TODO: 14: create generic JSON editor panel - show JSON blob and allow user to edit and save it (there should be ready-made solutions for this)-->
<!-- TODO: 15: nodes will "float" outside of viewport, after turning physics on/off -->
<!-- TODO: 16: need to find a way to do an ultra-efficient re-render of each node - -->
<!--only render changed nodes and do *not* re-render whole damn thing! -->

<!-- TODO:make initial separating force a little stronger, so that nodes are further apart (more spaced out). -->
<!-- TODO:2. on/in initial render, avoid crossing lines/edges -->
<!-- TODO: 3. avoid crossing links - https://stackoverflow.com/questions/74453071/avoid-crossing-links -->
<!-- TODO: 4. rendering is optimization problem, roughly: -->
<!--       * minimize link crossing/overlap. -->
<!--       * maximize space between nodes. -->
<!--       * but keep drawing within container.-->


<!--we are using version 7 of d3, use the minified version later -->
<script src="https://d3js.org/d3.v7.js"></script>

<script>

    document.turnOffSim = () => {
        alert('simulation not yet started.');
        // d3.force.stop()
    }

    const client = new WebSocket('ws://0.0.0.0:5900');

    client.addEventListener('message', m => {
        console.log('change event:', m);
        location.reload(); // reload page
    });

    client.addEventListener('error', e => {
        console.log('start ws server using start.js in the project root to get live updates.')
    });

    const program = {
        ctrlKey: false,
        metaKey: false
    };

    document.onkeydown = (event) => {
        if (event.key === 'Control') {  // this doesn't really seem to work
            program.ctrlKey = true;
        }
        if (event.key === 'Meta') {
            program.metaKey = true;
        }
        // console.log({program});
    };

    document.onkeyup = (event) => {
        if (event.key === 'Control') {  // this doesn't really seem to work
            program.ctrlKey = false;
        }
        if (event.key === 'Meta') {
            program.metaKey = true;
        }
        // console.log({program});
    };


    const colors = [
        'red',
        'blue',
        'brown',
        'indigo',
        'purple',
        'orange',
        'pink',
        'yellow',
        'maroon',
        'black',
        'magenta',
        'green',
        'gray',
        'violet'
    ];


    const width = window.innerWidth;
    const height = window.innerHeight;
    const minRadius = 20;
    // I just made up a formula, but radius should be a function of window size
    // (and eventually number of nodes as well)
    const nodeRadius = Math.max(minRadius, Math.floor(Math.min(width, height) / 25));
    // console.log("node radius: " + nodeRadius);

    let histogramShowing = false;

    const placeLabelsAndIcons = () => {
        const svg = d3.select("svg");

        if (!svg) {
            console.error('missing svg element.');
            return;
        }

        svg.selectAll("text").remove();
        svg.selectAll("image").remove();
        svg.selectAll("foreignObject").remove();

        const gs = svg.selectAll("g")
            .on('click', e => {
                //TODO: kind of a kludge here, there must be a way to access it cleaner?
//                 e.target.__data__.histogramShowing = !e.target.__data__.histogramShowing;
                // console.log(d.target.__data__.histogramShowing)
                // console.log(d3.select(this).histogramShowing)
                // d3.select(this).histogramShowing = true
                // d3.select(this)
                //     .style('background', '#ddd')
					histogramShowing = !histogramShowing;
					if (histogramShowing) {
						document.body.classList.add("show-histogram");
					} else {
						document.body.classList.remove("show-histogram");
					}
            });

        // svg.selectAll("g").on("click", d => { console.log("Clicked " + d.histogramShowing); });

        gs.append("image")
            .attr("x", d => d.x - d.size)
            .attr("y", d => d.y - 1.8 * d.size)
            .attr("width", d => d.size / 2)
            .attr("height", d => d.size / 2)
            .attr("href", d => d.iconUrl);

        // gs.append("text")
        // 	.attr("x", d => d.x + d.size / 2)
        // 	.attr("y", d => d.y - 1.9 * d.size)
        // 	.attr("text-anchor", "middle")
        // 	.text(d => 'ID: ' + d.id);

        gs.append("text")
            .attr("x", d => d.x + d.size / 3)
            .attr("y", d => d.y - 1.5 * d.size)
            .attr("text-anchor", "middle")
            .text(d => 'Name: ' + d.name);

        // gs.append("text")
        // 	.attr("x", d => d.x + d.size / 2)
        // 	.attr("y", d => d.y - 1.1 * d.size)
        //     .attr("text-anchor", "middle")
        // 	.text(d => 'Label: ' + d.label);

        let divs = gs.append("foreignObject")
            .attr("x", d => d.x - 70)
            .attr("y", d => d.y + 1.1 * d.size)
            .style("overflow", "visible")
            // .append(Histogram(d => d.histogram, {
            //     value: d => d.value,
            //     label: 'histogram data',
            //     width: 120,
            //     height: 60,
            //     color: "steelblue"
            // }))
            .append("xhtml:div")
//             .text(d => d.histogramShowing ? "histogram" : [
			.text(d => histogramShowing ? "histogram" : [
                '\nUpdates:', JSON.stringify(d.updateableFields),
                "\nID: ", d.id,
                "\nName:", d.name,
                '\nLabel:', d.label
            ].join(' '));
        
        for (const div of divs._groups[0]) {
			div.appendChild(getAndCacheHistogram(div.id));
		}
};
	const histoCache = {};
	const addToHistoCache = (id, value) => {
		histoCache[id] = value;
		return true;
	};
	const getHistoData = (id) => {
		return [{val: 9.5}, {val: 2}, {val: 2.5}, {val: 3}, {val: 3.3},
			{val: 4}, {val: 5.6}, {val: 2.1}, {val: 1.7}, {val: 7}];
	};
	const getAndCacheHistogram = (id) => {
		addToHistoCache(id, createHistogram(id) );
		return histoCache[id];
	};

	// Creating a basic histogram: https://d3-graph-gallery.com/graph/histogram_basic.html
	const createHistogram = (id) => {
		const data = getHistoData(id);

		// set the dimensions and margins of the graph
		const margin = {top: 10, right: 10, bottom: 10, left: 0},
			width = 120 - margin.left - margin.right,
			height = 50 - margin.top - margin.bottom;

		let histSvg = d3.select("div#secret")
			.append("svg")
			.attr("class", "histogram")
			.attr("width", width + margin.left + margin.right)
			.attr("height", height + margin.top + margin.bottom);

		histSvg.append("g")
			.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

		// And apply this function to data to get the bins
		const x = d3.scaleLinear()
			.domain([0, 10])     // can use this instead of 10 to have the max of data: d3.max(data, function(d) { return +d.value })
			.range([0, width]);
		histSvg.append("g")
			.attr("transform", "translate(0," + height + ")")
			.call(d3.axisBottom(x));

		// set the parameters for the histogram
		const histogram = d3.histogram()
			.value(function(d) { return d.val; })
			.domain(x.domain())
			.thresholds(x.ticks(10)); // number of bins

		const bins = histogram(data);

		// Y axis: scale and draw:
		const y = d3.scaleLinear()
			.range([height, 0]);
		y.domain([0, d3.max(bins, function(d) { return d.length; })]);
		histSvg.append("g")
			.call(d3.axisLeft(y));

		// append the bar rectangles to the svg element
		histSvg.selectAll("rect")
			.data(bins)
			.enter()
			.append("rect")
			.attr("x", 1)
			.attr("transform", function(d) { return "translate(" + x(d.x0) + "," + y(d.length) + ")"; })
			.attr("width", function(d) { return Math.max(0, x(d.x1) - x(d.x0) - 1) ; })
			.attr("height", function(d) { return height - y(d.length); })
			.style("fill", "#69b3a2");

		return histSvg.node();
	}

    const run = (nodes, links) => {


        setTimeout(() => {

            // TODO: dynamically add a new node/link
            // TODO: this doesn't work yet :/
            return;

            // dynamically add a new node
            nodes.push({
                color: colors[colorIndex++ % nodes.length],
                size: nodeRadius,
                label: 'Z',
                name: 'Z',
                id: 'Z',
                iconUrl: 'https://raw.githubusercontent.com/ORESoftware/d3-front-end/main/images/server-node.svg',
                histogram: [{value: 20}, {value: 30}, {value: 40}],
                histogramShowing: false
            });
            // dynamically add a new link
            links.push({
                source: 'Z',
                target: 'E'
            });
        }, 5000);



        const svg = d3.select('div#container')
            .append('svg')
            .attr("viewBox", "0 0 " + window.innerWidth + " " + window.innerHeight)
        // .classed("svg-content", true);



        const reDraw = () => {
            svg.selectAll(".link").remove();//add this to remove the links
            svg.selectAll(".gnode").remove();//add this to remove the nodes
        }


        // let svg = d3
        //     .select("svg")
        //     .attr("width", width)
        //     .attr("height", height);

        // svg.append("foreignObject")
        //         .attr("x", 100)
        //         .attr("y", 100)
        //         .style("overflow", "visible")
        //         // .append(Histogram(d => d.histogram, {
        //         //     value: d => d.value,
        //         //     label: 'histogram data',
        //         //     width: 120,
        //         //     height: 60,
        //         //     color: "steelblue"
        //         // }))
        //         .append("xhtml:div")
        //         .classed('controls', true)
        //         .text("histogram"); 

        // append a path marker to svg defs
        svg.append("defs").selectAll("marker")
            .data(["dominating"])
            .enter().append("marker")
            .attr("id", d => d)
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 0)
            .attr("refY", 0)
            .attr("markerWidth", 12)
            .attr("markerHeight", 12)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M0,-5L10,0L0,5");

        let linkSelection = svg
            .selectAll("line")
            .data(links)
            .enter()
            .append("line")
            .attr("stroke", "black")
            .attr("stroke-width", 1)
            // add marker to line
            .attr("marker-end", d => "url(#dominating)");


        let nodeSelection = svg
            .selectAll("circle")
            .data(nodes)
            .enter()
            .append("g")
            .append("circle")
            .attr("r", d => d.size)
            .attr("fill", d => d.color)
            .attr("img", d => d.icon)
            .call(
                d3
                    .drag()
                    .on("start", dragStart)
                    .on("drag", drag)
                    .on("end", dragEnd)
            );

        let simulation = d3.forceSimulation(nodes);

        let val = 0;
        setInterval(() => {

            console.log('udpating A...');

            data.formation[0].updateableFields.inc++;

           for(let i = 0; i < nodes.length; i++){
               // this doesn't really work to force a re-render
               const n = nodes[i];
               nodes[i] = Object.assign(n, {
                   updateableFields: {
                       ...n.updateableFields,
                       // increment some shit to force a re-render
                       inc: ++n.updateableFields.inc
                   }
               });
           }


            svg
                .selectAll("circle")
                // .data(nodes) // pass new data seems good idea
                .enter()
                // .attr("r", d => d.size)
                .attr(val++, val)
                .attr("fill", d => 'black')
                // .attr("img", d => d.icon)


            // simulation.alpha(0.5).restart()
            // placeLabelsAndIcons();
        }, 1000);

        document.turnOffSim = () => {
            simulation.stop(); // this works, but simulation restarts again on drag
            simulation .force("center", null)
                .force("nodes", null)
                .force("radial", null)
                .force("charge", null) // repulsion should scale with node size
                .force("collision", null)
                .force("links", null);
            // instead we want
        };

        document.turnOnSim = () => {
          simulation.force("center", d3.forceCenter(width / 2, height / 2))
                .force("nodes", d3.forceManyBody())
                .force("radial", d3.forceRadial(height, width / 2, height / 2))
                .force("charge", d3.forceManyBody().strength(-30 * nodeRadius)) // repulsion should scale with node size
                .force("collision", d3.forceCollide().radius(nodeRadius / 2))
                .force(
                "links",
                d3
                    .forceLink(links)
                    .id(d => d.id)
                    // .distance(d => 5 * (d.source.size + d.target.size))
                    // TODO force distance between all elements, not just connected ones
                    // TODO in fact, force should be greater amongst non-connected elements
                    // TODO idea - force should increase as degree of freedom between nodes increases
                    .distance((d, a, b) => {
                        // we set the new distance pressure to the current distance
                        return 0.5 * Math.sqrt(
                            Math.pow(d.source.x - d.target.x, 2) + Math.pow(d.source.y - d.target.y, 2)
                        );
                    })
            )
           // this works, but simulation restarts again on drag
            // instead we want
        }

        simulation
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("nodes", d3.forceManyBody())
            .force("radial", d3.forceRadial(height, width / 2, height / 2))
            .force("charge", d3.forceManyBody().strength(-30 * nodeRadius)) // repulsion should scale with node size
            .force("collision", d3.forceCollide().radius(nodeRadius / 2))
            // .force('collide', d3.forceCollide().radius(function(d) {
            //     return d.radius + 150;
            // }))
            // .linkDistance(1)
            .force(
                "links",
                d3
                    .forceLink(links)
                    .id(d => d.id)
                    // .distance(d => 5 * (d.source.size + d.target.size))
                    // TODO force distance between all elements, not just connected ones
                    // TODO in fact, force should be greater amongst non-connected elements
                    // TODO idea - force should increase as degree of freedom between nodes increases
                    .distance((d, a, b) => {
                        // console.log({d, a, b});
                        return 3 * (d.source.size + d.target.size);
                    })
            )
            .on("tick", ticked);

        // data.nodes contains all nodes
        // for(let i = 0; i < nodes.length - 1; i++) {
        //     for(let j = i + 1; j < nodes.length; j++) {
        //         simulation.force();
        //     }
        // }

        function ticked() {
            // console.log(simulation.alpha());

            nodeSelection.attr("cx", d => d.x).attr("cy", d => d.y);

            linkSelection
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);


            // recalculate and back off the distance
            linkSelection.each(function (d, i, n) {
                // current path length
                const pl = this.getTotalLength();
                // radius of marker head plus def constant
                const mrs = (d.source.size);
                const mrt = (d.target.size) + 12;
                // get new start and end points
                const m1 = this.getPointAtLength(mrs);
                const m2 = this.getPointAtLength(pl - mrt);
                // new line start and end
                d3.select(n[i])
                    .attr("x1", m1.x)
                    .attr("y1", m1.y)
                    .attr("x2", m2.x)
                    .attr("y2", m2.y);
            });

            placeLabelsAndIcons();
        }

        function dragStart(event, d) {
            // console.log('drag start');
            simulation.alphaTarget(0.5).restart();
            d.fx = d.x;
            d.fy = d.y;
            placeLabelsAndIcons();
        }

        function drag(event, d) {
            // console.log('dragging', event, d);
            // simulation.alpha(0.5).restart()
            d.fx = event.x;
            d.fy = event.y;
            placeLabelsAndIcons();
            // d.fx = d3.event.x;
            // d.fy = d3.event.y;
        }

        function dragEnd(event, d) {
            // console.log('drag end');
            placeLabelsAndIcons();
            simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
            placeLabelsAndIcons();
        }
    }


    const nodes = [];
    const links = [];

    let colorIndex = nodes.length - 1;

    const data = {
        formation: [
            {
                "name": "A",
                "id": "A",
                "entity": {
                    "initialGraphData": true
                },
                "iconUrl": "https://oyster.ignimgs.com/mediawiki/apis.ign.com/new-super-mario-bros-u/4/48/Yoshi.png",
                "label": "A",
                "connectionsOut": [
                    "B", "C"
                ],
                "updateableFields": {
                    inc: 1
                }
            },
            {
                "name": "F",
                "id": "F",
                "entity": {
                    "initialGraphData": true
                },
                "iconUrl": "https://oyster.ignimgs.com/mediawiki/apis.ign.com/new-super-mario-bros-u/4/48/Yoshi.png",
                "label": "F",
                "connectionsOut": [
                    "C"
                ],
                "updateableFields": {
                    inc: 1
                }
            },
            {
                "name": "B",
                "id": "B",
                "entity": {
                    "initialGraphData": true
                },
                "iconUrl": "https://oyster.ignimgs.com/mediawiki/apis.ign.com/new-super-mario-bros-u/4/48/Yoshi.png",
                "label": "B",
                "connectionsOut": [
                    "C"
                ],
                "updateableFields": {
                    inc: 1
                }
            },
            {
                "name": "C",
                "id": "C",
                "entity": {
                    "initialGraphData": true
                },
                "iconUrl": "./images/arrow-sink.svg",
                "label": "C",
                "connectionsOut": [
                    "D"
                ],
                "updateableFields": {
                    inc: 1
                }
            },
            {
                "name": "D",
                "id": "D",
                "entity": {
                    "initialGraphData": true
                },
                "iconUrl": "./images/arrow-source.svg",
                "label": "D",
                "connectionsOut": [
                    "E"
                ],
                "updateableFields": {
                    inc: 1
                }
            },
            {
                "name": "E",
                "id": "E",
                "entity": {
                    "initialGraphData": true
                },
                "iconUrl": "./images/noun-up-3815871.svg",
                "label": "E",
                "connectionsOut": [],
                "updateableFields": {
                    inc: 1
                }
            },

        ]
    }



    if (data.formation) {
        for (const z of data.formation) {

            nodes.push({
                color: colors[colorIndex++ % nodes.length],
                size: nodeRadius,
                label: z.label,
                name: z.name,
                id: z.id,
                iconUrl: z.iconUrl,
                histogram: [{value: 20}, {value: 30}, {value: 40}],
                histogramShowing: false,
                updateableFields: z.updateableFields
            });

            // we only need-be concerned with connectionsOut, not connectionsIn, in order to complete graph
            for (const targetId of z.connectionsOut) {
                links.push({source: z.id, target: targetId, ...{whatever: 'else'}});
            }
        }

        // for (const v of nodes) {
        //   console.log(v);
        // }
        //
        // for (const v of links) {
        //   console.log(v);
        // }

        run(nodes, links);
    }

</script>
</body>
</html>

