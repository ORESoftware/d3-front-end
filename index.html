<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <link rel="stylesheet" href="style.css"/>
    <title>Dragging Nodes and Alpha Values</title>
</head>

<style>
    body {
        margin: 0;
        background: #eee;
    }

    .svg-container {
        display: inline-block;
        position: relative;
        width: 90vw;
        height: 90vh;
        margin:20px;
        vertical-align: top;
        overflow: hidden;
    }

    .svg-content {
        display: inline-block;
        position: absolute;
        top: 0;
        left: 0;
    }

    g {
		opacity: 0.85;
		overflow: visible;
		cursor: default;
	}

	g:hover {
		opacity: 1;
	}

	g div {
		height: 60px;
		width: 120px;
		padding: 10px;
		background: #fff;
		text-align: center;
		vertical-align: middle;
		white-space: pre;
		visibility: hidden;
        border-radius: 10px;
        box-shadow: 0 0 6px rgba(0, 0, 0, 0.6);
	}

	g:hover div {
		visibility: visible;
	}
/* 
    g image {
        visibility: hidden;
    }
    
    g:hover image {
        visibility: visible;
    } */
</style>

<body>

<div id="container" class="svg-container">
    <svg
            version="1.1"
            baseProfile="full"
            xmlns="http://www.w3.org/2000/svg"
            preserveAspectRatio="xMidYMid meet"
    ></svg>
</div>

<!-- * TODO: 1. scale drawing to 90% of viewport (vertically and horizontally) -->
<!-- TODO: 2. add permanent labels to nodes -->
<!-- TODO: 3. add permanent icons to nodes (any image url is fine for now)-->
<!-- X TODO: 4. allow for triangle or rectangular shapes in nodes -->
<!-- ** TODO: 5. add on-hover text (show metadata when hovering over) -->
<!-- TODO: 6. add dynamic text above node (gets updated constantly from backend) -->
<!-- TODO: 7. add dynamic images/drawings/animation along links (gets updated constantly from backend) -->
<!-- TODO: 8. change forces so the more force between nodes given more degrees of separation/freedom -->
<!-- TODO: 9. allow user to toggle on/off nodes self-separating - default is on - if it's off: then user can drag nodes wherever they want  -->
<!-- ** TODO: 10: on-hover over node -> show histogram -->
<!-- ** TODO: 11: on-hover over link -> show histogram -->

<!-- TODO:make initial separating force a little stronger, so that nodes are further apart (more spaced out). -->
<!-- TODO:2. on/in initial render, avoid crossing lines/edges -->
<!-- TODO: 3. avoid crossing links - https://stackoverflow.com/questions/74453071/avoid-crossing-links -->
<!-- TODO: 4. rendering is optimization problem, roughly: -->
<!--       * minimize link crossing/overlap. -->
<!--       * maximize space between nodes. -->
<!--       * but keep drawing within container.-->


<!--we are using version 7 of d3, use the minified version later -->
<script src="https://d3js.org/d3.v7.js"></script>

<script>

    const fisherYatesShuffle = function* (deck) {
        for (let i = deck.length - 1; i >= 0; i--) {
            const swapIndex = Math.floor(Math.random() * (i + 1));
            [deck[i], deck[swapIndex]] = [deck[swapIndex], deck[i]];
            yield deck[i];
        }
    };

    const colors = [
        'red',
        'blue',
        'indigo',
        'violet',
        'purple',
        'orange',
        'pink',
        'yellow',
        'maroon',
        'black'
    ];

    // ** TODO: https://chartio.com/resources/tutorials/how-to-resize-an-svg-when-the-window-is-resized-in-d3-js/

	const width = window.innerWidth;
	const height = window.innerHeight;
	const minRadius = 20;
	// I just made up a formula, but radius should be a function of window size
	// (and eventually number of nodes as well)
	const nodeRadius = Math.max(minRadius, Math.floor(Math.min(width, height) / 25));
	// console.log("node radius: " + nodeRadius);

    let histogramShowing = false;

	const placeLabelsAndIcons = () => {
		const svg = d3.select("svg");

		if (svg) {
			svg.selectAll("text").remove();
			svg.selectAll("image").remove();
			svg.selectAll("foreignObject").remove();

			const gs = svg.selectAll("g")
                .on('click', d => {
                    histogramShowing = !histogramShowing;
                    // console.log(d3.select(this).histogramShowing) 
                    // d3.select(this).histogramShowing = true
                    // d3.select(this)
                    //     .style('background', '#ddd')
                });

            // svg.selectAll("g").on("click", d => { console.log("Clicked " + d.histogramShowing); });

			gs.append("image")
				.attr("x", d => d.x - d.size )
				.attr("y", d => d.y - 1.8 * d.size)
				.attr("width", d => d.size /2)
				.attr("height", d => d.size /2)
				.attr("href", d => d.iconUrl);

            // gs.append("text")
			// 	.attr("x", d => d.x + d.size / 2)
			// 	.attr("y", d => d.y - 1.9 * d.size)
			// 	.attr("text-anchor", "middle")
			// 	.text(d => 'ID: ' + d.id);

			gs.append("text")
				.attr("x", d => d.x + d.size / 3)
				.attr("y", d => d.y - 1.5 * d.size)
				.attr("text-anchor", "middle")
				.text(d => 'Name: ' + d.name);

			// gs.append("text")
			// 	.attr("x", d => d.x + d.size / 2)
			// 	.attr("y", d => d.y - 1.1 * d.size)
            //     .attr("text-anchor", "middle")
			// 	.text(d => 'Label: ' + d.label);

			gs.append("foreignObject")
				.attr("x", d => d.x - 70)
				.attr("y", d => d.y + 1.1 * d.size)
				.style("overflow", "visible")
				.append("xhtml:div")
				.text(d => histogramShowing ? "histogram" : "ID: " + d.id + "\nName: " + d.name + '\nLabel: ' + d.label);
    	}
    };

    const run = (nodes, links) => {

        setInterval(() => {
            for(const n of fisherYatesShuffle(nodes)){
                // update node with id = n.id
                // TODO: dynamically update nodes in network here
                // TODO: down the line, will be updated with websocket conn
            }

			// placeLabelsAndIcons();
        }, 2000);

        let svg = d3
            .select("svg")
            .attr('viewBox',`0 0 ${width} ${height}`)
            .attr("width", width)
            .attr("height", height);

        // append a path marker to svg defs
        svg.append("defs").selectAll("marker")
            .data(["dominating"])
            .enter().append("marker")
            .attr("id", d => d)
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 0)
            .attr("refY", 0)
            .attr("markerWidth", 12)
            .attr("markerHeight", 12)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M0,-5L10,0L0,5");

        let linkSelection = svg
            .selectAll("line")
            .data(links)
            .enter()
            .append("line")
            .attr("stroke", "black")
            .attr("stroke-width", 1)
            // add marker to line
            .attr("marker-end", d => "url(#dominating)");


        let nodeSelection = svg
            .selectAll("circle")
            .data(nodes)
            .enter()
            .append("g")
            .append("circle")
            .attr("r", d => d.size)
            .attr("fill", d => d.color)
            .attr("img", d => d.icon)
            .call(
                d3
                    .drag()
                    .on("start", dragStart)
                    .on("drag", drag)
                    .on("end", dragEnd)
            );

        let simulation = d3.forceSimulation(nodes);

        simulation
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("nodes", d3.forceManyBody())
            .force("radial", d3.forceRadial(240, width / 2, height / 2))
            .force("charge", d3.forceManyBody().strength(-20 * nodeRadius)) // repulsion should scale with node size
            // .force("collision", d3.forceCollide().radius(100))
            // .force('collide', d3.forceCollide().radius(function(d) {
            //     return d.radius + 150;
            // }))
            // .linkDistance(1)
            .force(
                "links",
                d3
                    .forceLink(links)
                    .id(d => d.id)
                    // .distance(d => 5 * (d.source.size + d.target.size))
                    // TODO force distance between all elements, not just connected ones
                    // TODO in fact, force should be greater amongst non-connected elements
                    // TODO idea - force should increase as degree of freedom between nodes increases
                    .distance((d,a,b) => {
                        console.log({d, a, b});
                        return 3 * (d.source.size + d.target.size);
                    })
            )
            .on("tick", ticked);

        // function isolate(force, nodeA, nodeB) {
        //     let initialize = force.initialize;
        //     force.initialize = function() {
        //         initialize.call(force, [nodeA, nodeB]);
        //     };
        //     return force;
        // }

        // data.nodes contains all nodes
        // for(let i = 0; i < nodes.length - 1; i++) {
        //     for(let j = i + 1; j < nodes.length; j++) {
        //         simulation.force();
        //     }
        // }

        function ticked() {
            // console.log(simulation.alpha());

            nodeSelection.attr("cx", d => d.x).attr("cy", d => d.y);

            linkSelection
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);


            // recalculate and back off the distance
            linkSelection.each(function (d, i, n) {
                // current path length
                const pl = this.getTotalLength();
                // radius of marker head plus def constant
                const mrs = (d.source.size);
                const mrt = (d.target.size) + 12;
                // get new start and end points
                const m1 = this.getPointAtLength(mrs);
                const m2 = this.getPointAtLength(pl - mrt);
                // new line start and end
                d3.select(n[i])
                    .attr("x1", m1.x)
                    .attr("y1", m1.y)
                    .attr("x2", m2.x)
                    .attr("y2", m2.y);
            });

            placeLabelsAndIcons();
        }

        function dragStart(event, d) {
            // console.log('drag start');
            simulation.alphaTarget(0.5).restart();
            d.fx = d.x;
            d.fy = d.y;
            placeLabelsAndIcons();
        }

        function drag(event, d) {
            // console.log('dragging', event, d);
            // simulation.alpha(0.5).restart()
            d.fx = event.x;
            d.fy = event.y;
            placeLabelsAndIcons();
            // d.fx = d3.event.x;
            // d.fy = d3.event.y;
        }

        function dragEnd(event, d) {
            // console.log('drag end');
            placeLabelsAndIcons();
            simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
            placeLabelsAndIcons();
        }

        d3.select(window).on('resize', resize); 

        function resize() {

            let newHeight = window.innerHeight;
            let newWidth = window.innerHeight;

            // There is still a small bug when you resize back up, need to dig in deeper.
            // I think the viewBox has something to do with it.

            d3
            .select("svg")
            // .attr('viewBox',`0 0 ${newWidth} ${newHeight}`)
            .attr("width", newWidth)
            .attr("height", newHeight);

        }
    }


    const nodes = [];
    const links = [];

    const data = {
        formation: [
            {
                "name": "A",
                "id": "A",
                "entity": {
                    "initialGraphData": true
                },
                "iconUrl": "https://oyster.ignimgs.com/mediawiki/apis.ign.com/new-super-mario-bros-u/4/48/Yoshi.png",
                "label": "A",
                "connectionsOut": [
                    "B", "C"
                ]
            },
            {
                "name": "F",
                "id": "F",
                "entity": {
                    "initialGraphData": true
                },
                "iconUrl": "https://oyster.ignimgs.com/mediawiki/apis.ign.com/new-super-mario-bros-u/4/48/Yoshi.png",
                "label": "F",
                "connectionsOut": [
                   "C"
                ]
            },
            {
                "name": "B",
                "id": "B",
                "entity": {
                    "initialGraphData": true
                },
                "iconUrl": "https://oyster.ignimgs.com/mediawiki/apis.ign.com/new-super-mario-bros-u/4/48/Yoshi.png",
                "label": "B",
                "connectionsOut": [
                    "C"
                ]
            },
            {
                "name": "C",
                "id": "C",
                "entity": {
                    "initialGraphData": true
                },
                "iconUrl": "https://oyster.ignimgs.com/mediawiki/apis.ign.com/new-super-mario-bros-u/4/48/Yoshi.png",
                "label": "C",
                "connectionsOut": [
                    "D"
                ]
            },
            {
                "name": "D",
                "id": "D",
                "entity": {
                    "initialGraphData": true
                },
                "iconUrl": "https://oyster.ignimgs.com/mediawiki/apis.ign.com/new-super-mario-bros-u/4/48/Yoshi.png",
                "label": "D",
                "connectionsOut": [
                    "E"
                ]
            },
            {
                "name": "E",
                "id": "E",
                "entity": {
                    "initialGraphData": true
                },
                "iconUrl": "https://oyster.ignimgs.com/mediawiki/apis.ign.com/new-super-mario-bros-u/4/48/Yoshi.png",
                "label": "E",
                "connectionsOut": []
            }
        ]
    }

    if (data.formation) {
        for (const z of data.formation) {

            nodes.push({
                color: colors.shift(),
                size: nodeRadius, // TODO: size should be dynamic/scaled, but with a minimum and maximum size
                label: z.label,
                name: z.name,
                id: z.id,
                iconUrl: z.iconUrl,
                histogram: new Map(),
                // histogramShowing: false
            });

            // we only need-be concerned with connectionsOut, not connectionsIn, in order to complete graph
            for (const targetId of z.connectionsOut) {
                links.push({source: z.id, target: targetId, ...{whatever: 'else'}});
            }
        }

        // for (const v of nodes) {
        //   console.log(v);
        // }
        //
        // for (const v of links) {
        //   console.log(v);
        // }

        run(nodes, links);
    }


</script>
</body>
</html>

