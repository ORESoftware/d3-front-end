<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <link rel="stylesheet" href="style.css"/>
    <title>Dragging Nodes and Alpha Values</title>
</head>

<style>
    .svg-container {
        display: inline-block;
        position: relative;
        width: 100%;
        padding-bottom: 100%;
        vertical-align: top;
        overflow: hidden;
    }

    .svg-content {
        display: inline-block;
        position: absolute;
        top: 0;
        left: 0;
    }
</style>

<body>

<div id="container" class="svg-container">
    <svg
            version="1.1"
            baseProfile="full"
            xmlns="http://www.w3.org/2000/svg"
            preserveAspectRatio="xMidYMid meet"
    ></svg>
</div>

<!-- TODO: 0. can we get the same code to work with version 7 of d3 instead of 4? https://github.com/d3/d3/releases -->
<!-- TODO: 1. scale drawing to 90% of viewport (vertically and horizontally -->
<!-- TODO: 2. add permanent labels to nodes -->
<!-- TODO: 3. add permanent icons to nodes (any image url is fine for now)-->
<!-- TODO: 4. allow for triangle or rectangular shapes in nodes -->
<!-- TODO: 5. add on-hover text (show metadata when hovering over) -->
<!-- TODO: 6. add dynamic text above node (gets updated constantly from backend) -->
<!-- TODO: 7. add dynamic images/drawings/animation (gets updated constantly from backend) -->


<script src="https://d3js.org/d3.v4.js"></script>

<script>

    const fisherYatesShuffle = function* (deck) {
        for (let i = deck.length - 1; i >= 0; i--) {
            const swapIndex = Math.floor(Math.random() * (i + 1));
            [deck[i], deck[swapIndex]] = [deck[swapIndex], deck[i]];
            yield deck[i];
        }
    };

    const colors = [
        'red',
        'blue',
        'indigo',
        'violet',
        'purple',
        'orange',
        'pink',
        'yellow',
        'maroon',
        'black'
    ];


    // TODO: https://chartio.com/resources/tutorials/how-to-resize-an-svg-when-the-window-is-resized-in-d3-js/

    const run = (nodes, links) => {

        setInterval(() => {
            for(const v of fisherYatesShuffle(nodes)){
                // update node with id v.id
                // TODO: dynamically update nodes in network here
            }
        }, 2000);

        var width = 1900;
        var height = 500;

        var svg = d3
            .select("svg")
            .attr("width", width)
            .attr("height", height);

        // append a path marker to svg defs
        svg.append("defs").selectAll("marker")
            .data(["dominating"])
            .enter().append("marker")
            .attr("id", d => d)
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 0)
            .attr("refY", 0)
            .attr("markerWidth", 12)
            .attr("markerHeight", 12)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M0,-5L10,0L0,5");

        var linkSelection = svg
            .selectAll("line")
            .data(links)
            .enter()
            .append("line")
            .attr("stroke", "black")
            .attr("stroke-width", 1)
            // add marker to line
            .attr("marker-end", d => "url(#dominating)");


        var nodeSelection = svg
            .selectAll("circle")
            .data(nodes)
            .enter()
            .append("circle")
            .attr("r", d => d.size)
            .attr("fill", d => d.color)
            .attr("img", d => d.icon)
            .call(
                d3
                    .drag()
                    .on("start", dragStart)
                    .on("drag", drag)
                    .on("end", dragEnd)
            );


        var simulation = d3.forceSimulation(nodes);

        simulation
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("nodes", d3.forceManyBody())
            .force(
                "links",
                d3
                    .forceLink(links)
                    .id(d => d.id)
                    .distance(d => 5 * (d.source.size + d.target.size))
            )
            .on("tick", ticked);

        function ticked() {
            // console.log(simulation.alpha());

            nodeSelection.attr("cx", d => d.x).attr("cy", d => d.y);

            linkSelection
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);


            // recalculate and back off the distance
            linkSelection.each(function (d, i, n) {
                // current path length
                const pl = this.getTotalLength();
                // radius of marker head plus def constant
                const mrs = (d.source.size);
                const mrt = (d.target.size) + 12;
                // get new start and end points
                const m1 = this.getPointAtLength(mrs);
                const m2 = this.getPointAtLength(pl - mrt);
                // new line start and end
                d3.select(n[i])
                    .attr("x1", m1.x)
                    .attr("y1", m1.y)
                    .attr("x2", m2.x)
                    .attr("y2", m2.y);
            });
        }

        function dragStart(d) {
            // console.log('drag start');
            simulation.alphaTarget(0.5).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function drag(d) {
            // console.log('dragging');
            // simulation.alpha(0.5).restart()
            d.fx = d3.event.x;
            d.fy = d3.event.y;
        }

        function dragEnd(d) {
            // console.log('drag end');
            simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }
    }


    const nodes = [];
    const links = [];

    const data = {
        formation: [
            {
                "name": "A",
                "id": "A",
                "entity": {
                    "initialGraphData": true
                },
                "iconUrl": "https://xyz.com",
                "label": "A",
                "connectionsOut": [
                    "B", "C"
                ]
            },
            {
                "name": "F",
                "id": "F",
                "entity": {
                    "initialGraphData": true
                },
                "iconUrl": "https://xyz.com",
                "label": "F",
                "connectionsOut": [
                   "C"
                ]
            },
            {
                "name": "B",
                "id": "B",
                "entity": {
                    "initialGraphData": true
                },
                "iconUrl": "https://xyz.com",
                "label": "B",
                "connectionsOut": [
                    "C"
                ]
            },
            {
                "name": "C",
                "id": "C",
                "entity": {
                    "initialGraphData": true
                },
                "iconUrl": "https://xyz.com",
                "label": "C",
                "connectionsOut": [
                    "D"
                ]
            },
            {
                "name": "D",
                "id": "D",
                "entity": {
                    "initialGraphData": true
                },
                "iconUrl": "https://xyz.com",
                "label": "D",
                "connectionsOut": [
                    "E"
                ]
            },
            {
                "name": "E",
                "id": "E",
                "entity": {
                    "initialGraphData": true
                },
                "iconUrl": "https://xyz.com",
                "label": "E",
                "connectionsOut": []
            }
        ]
    }

    if (data.formation) {
        for (const z of data.formation) {
            nodes.push({color: colors.shift(), size: 20, label: z.label, name: z.name, id: z.id});
            for (const connId of z.connectionsOut) {
                links.push({source: z.id, target: connId});
            }
        }

        // for (const v of nodes) {
        //   console.log(v);
        // }
        //
        // for (const v of links) {
        //   console.log(v);
        // }

        run(nodes, links);
    }


</script>
</body>
</html>

